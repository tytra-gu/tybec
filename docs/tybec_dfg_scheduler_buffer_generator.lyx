#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble



% Title Page
\title{TyTra Backend - Design Document}
\author{Waqar Nabi}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding auto
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "commentstyle={\color{red}},keywordstyle={\color{blue}},keywordstyle={\color{black}\bfseries\underbar},stringstyle={\ttfamily}"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter*
TyBEC Dataflow Scheduler and Buffer Generator
\end_layout

\begin_layout Standard
S.
 Waqar Nabi, June 2017
\end_layout

\begin_layout Section*
DFG Generated by TyBEC
\end_layout

\begin_layout Standard
TyBEC will parse TIR code and will internally create a DFG for the given
 design.
 asdf
\end_layout

\begin_layout Section*
Synchronous Domains, Asynchronous Gates, and the STALL signal
\end_layout

\begin_layout Standard
The DFG will be consist of one or more of 
\emph on
Synchronous Domains (SD).
 
\emph default
This will be a collection of nodes that can be deterministically scheduled
 at compile-time with respect to each other.
 The scheduling is discussed later.
\end_layout

\begin_layout Standard
SD's will connect externally via specialized nodes called 
\emph on
Asynchronous Gates (A-gates).
 
\emph default
In the simplest case, these A-gates will be communicating with the external
 DRAM (global memory).
 They can however also refer to channels talking to other devices in a multi-dev
ice scenario.
 In the context of TyBEC-generated designs, the communication between HDLs
 and their AOCL wrappers would be via A-gates, as these boundaries communication
s are always asyncrhonous and require handshaking.
 
\end_layout

\begin_layout Standard
All A-gates will be able to 
\emph on
stall 
\emph default
the entire SD anytime by asserting the STALL signal to all the nodes, e.g.,
 in case where the input stream from a DRAM via an A-gate is not available.
\end_layout

\begin_layout Section*
Node Types
\end_layout

\begin_layout Standard
- Memory objects 
\end_layout

\begin_layout Standard
- SSA variables 
\end_layout

\begin_layout Standard
- autoindex 
\end_layout

\begin_layout Standard
- arguments (ports) 
\end_layout

\begin_layout Standard
- functions (inside hierarchical nodes) 
\end_layout

\begin_layout Standard
- smache (for offset buffer creation).
\end_layout

\begin_layout Section*
Edge Types
\end_layout

\begin_layout Standard
Edges will map to streams.
\end_layout

\begin_layout Standard
- Explicit: using streamread/streamwrite 
\end_layout

\begin_layout Standard
- Implicit: using SSA instructions 
\end_layout

\begin_layout Section*
FIFO/Syncrhonization Buffers
\end_layout

\begin_layout Standard
Some edges will require buffers for syncrhonization.
 They are of two types:
\end_layout

\begin_layout Standard
- Explicit: using ALLOCA instructios 
\end_layout

\begin_layout Standard
- Implicit: Inferred on edges (streams) for synch
\end_layout

\begin_layout Section*
Node Parameters
\end_layout

\begin_layout Standard
For the purpose of scheduling, every 
\emph on
node
\emph default
 in a TyBEC DFG graph will be desribed by these parameters
\begin_inset Foot
status open

\begin_layout Plain Layout
Each node will also have parameters for the purpose of 
\emph on
costing
\emph default
; they will be discussed elsewhere.
\end_layout

\end_inset

: 
\end_layout

\begin_layout Standard
LAT = latency (input to output).
 
\end_layout

\begin_layout Standard
LFI = Local Firing Interval: How soon can subsequent executions on this
 node be fired, based ONLY on internal constraints (e..g if the node has >1
 latency and is not i internally pipelined, then we have to wait for LAT
 before firing it again, even if data is available at its input.
 
\end_layout

\begin_layout Standard
EFI = External Firing interval: The firing interval determined by how frequently
 data ia made available by predecessor(s).
 
\end_layout

\begin_layout Standard
AFI = Actual Firing Interval: This will look at both LFI and the constraints
 of firing due to availability of data at input (i.e.
 AFI_p x FPO_p) 
\end_layout

\begin_layout Standard
FPO = Firings per output 
\end_layout

\begin_layout Standard
SD = Starting delay (based on synch-domain counter)
\end_layout

\begin_layout Section*
Scheduling
\end_layout

\begin_layout Standard
With the nodes as described by a five-parameter tuple, i.e.
 (LAT, LFI, EFI, AFI, FPO, SD), scheduling means calculating all these parameter
s for all nodes.
 They will be calculated as follows, where 
\begin_inset Formula $(TIR)$
\end_inset

 means the paramter is derived directly from the TIR, so is known when the
 scheduling algorithm is run.
 
\end_layout

\begin_layout Standard
If there are multiple predecessors, then we calculate for all of them, and
 choose the maximum value.
\end_layout

\begin_layout Subsection*
For leaf nodes
\end_layout

\begin_layout Standard
All non-function nodes are leaf nodes.
 E.g.
 args, primitive instructions like add, mul etc, and inferred nodes like
 smache.
 
\end_layout

\begin_layout Standard
\begin_inset Formula $LAT_{not.reduction}=latencyOfPrimitiveInstruction$
\end_inset


\end_layout

\begin_layout Standard
This latency of a primitive instruction would be available via a cost model
 (e.g.
 1 for integer addition, 5 for floating point addition).
\end_layout

\begin_layout Standard
However, if the primitive instruction is a reduction operation, then the
 latency has to take into account the size of the array, and also the way
 in which the reduction is carried out:
\end_layout

\begin_layout Standard
\begin_inset Formula $LATl_{linear.reduction}=latencyOfPrimitiveInstruction+SizeOfReduction-1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LAT_{tree.reduction}=latencyOfPrimitiveInstruction+...$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LFI=(TIR)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $EFI=AFI_{p}\times FPO_{p}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $AFI=max(LFI,EFI)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $FPO=(TIR)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SD_{inputNode}=SD_{parentFunction}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SD_{nonInputNode}=SD_{p}+(LAT_{p}-1)+(AFI_{p}\times FPO_{p})$
\end_inset


\end_layout

\begin_layout Standard
Since all output streams from a function have to be instep for scheduling
 at the next hierarchical level to work, we need to make sure all output
 nodes have same starting delay.
 The 
\begin_inset Formula $SD_{nonInputNode}$
\end_inset

shown above may lead to output nodes that are out of step.
 So, for output nodes, we need to set the SD to the maximim or all output
 nodes.
\end_layout

\begin_layout Standard
\begin_inset Formula $SD_{node}=max(SD_{allOutputNodes})$
\end_inset


\end_layout

\begin_layout Standard
The SD of 
\series bold
all 
\series default
output nodes in a function must be 
\end_layout

\begin_layout Subsection*
For heirarchical nodes (functions)
\end_layout

\begin_layout Standard
This refers to both leaf functions
\begin_inset Foot
status open

\begin_layout Plain Layout
 Note: leaf function is not the same as leaf node.
\end_layout

\end_inset

.
 We assume that input nodes and terminal nodes are symmetrical.
 If not, then we need to re-consider (TODO).
\end_layout

\begin_layout Standard
\begin_inset Formula $LAT=SD_{outputNode}+LAT_{outputNode}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $LFI=LFI_{inputNode}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $EFI=AFI_{p}\times FPO_{p}$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $AFI=max(LFI,EFI)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $FPO=FPO_{outputNode}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SD=SD_{p}+(LAT_{p}-1)+(AFI_{p}\times FPO_{p})$
\end_inset


\end_layout

\begin_layout Standard
TODO: How are these expressions effected when we split/merge?
\end_layout

\begin_layout Subsection*
For MAIN (Asychronous Gates)
\end_layout

\begin_layout Subsubsection*
Global Variables (alloca in addrspace = 1)
\end_layout

\begin_layout Standard
Main is the only function that talks to global memories (for now), and is
 the boundary for the IR design, so it needs to be treated slighltly differently
 fron other functions.
 The key thing to note here is that access to a variable in the global memory
 implies an 
\series bold
Asynchronous Gate
\series default
, and thus it does not require deterministuc scheduling like the other nodes.
 With the implicit understanding that there will be a handshaking protocol
 to deal with the asyncrhonity at these gates, for the purpose of scheduling
 we can then assume that these nodes are always ready to 
\emph on
fire, 
\emph default
have no latency, and start at time 0.
\end_layout

\begin_layout Standard
\begin_inset Formula $LAT=0$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $LFI=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $EFI=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $AFI=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $FPO=1$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $SD=0$
\end_inset


\end_layout

\begin_layout Section*
Edge FIFO Buffers Sizes
\end_layout

\begin_layout Standard
FIFO buffers will be required on the edges for synchronization in a number
 of different cases.
\end_layout

\begin_layout Subsection*
Case 1 - Mismatched latenies
\end_layout

\begin_layout Standard
For inferring buffers when the only syncrhonization requirement is due to
 different latencies of predecessor nodes, leading to different starting-delays
 on incoming edges, the SD is chosen to me the maximum one, and all other
 paths will require a buffer of this size:
\end_layout

\begin_layout Standard
\begin_inset Formula $fifodepth_{edgeA}=SD_{longest-path-on-input-edges}-SD_{edgeA}$
\end_inset


\end_layout

\begin_layout Subsection*
Case 2 - Mismatched rates between producer and consumer
\end_layout

\begin_layout Standard
When the producer is producing faster than the consumer can consume (i.e.
 
\begin_inset Formula $EFI_{p}<LFI_{p}$
\end_inset

) , then one approach is to stall the producer.
 But here we assume that we do not want to stall the producer, so we have
 to introduce a buffer that looks at the size of the entire stream, and
 then infers a buffer size that makes sure there is enough buffer space
 in view of the rate differences.
\begin_inset Foot
status open

\begin_layout Plain Layout
If this turns out to be too large for the FPGA resources, then our cost-model
 should tell us, in which case we fall back to stalling the pipeline.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $fifodepth_{edgeA}=\frac{size}{EFI_{p}}-\frac{size}{LFI_{A}}$
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $size$
\end_inset

 refers to the total size of the stream.
\end_layout

\begin_layout Standard
TODO: Synchronizaing multiple predecessors producing at different rates.
\end_layout

\begin_layout Subsection*
Case 3 - Combination of maps and folds (mismatched FPOs)
\end_layout

\begin_layout Standard
If there is a map and fold on parallel paths (as is the case in the HIPEAC
 illustration), then we need to infer a buffer on the map path.
 In this case, the fold node will have an 
\begin_inset Formula $FPO$
\end_inset

 that is greater than the 
\begin_inset Formula $FPO$
\end_inset

 of the map path which would be 1.
 In such case, we simply infer a buffer on the map path as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula $fifodepth_{edgeMap}=FPO_{fold}-FPO_{map}$
\end_inset


\end_layout

\begin_layout Standard
This should be a general expression for the case when multiple predecessors
 to a node have different FPOs, and not necessarily limited to this particular
 illustration of map and fold on a parallel path.
\end_layout

\begin_layout Subsection*
Case 4 - Combination of cases - TODO
\end_layout

\begin_layout Standard
Also TODO: Verify all these expressions.
\end_layout

\end_body
\end_document
